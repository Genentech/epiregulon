#' Establish peak to gene links based on correlations between ATAC-seq peaks and RNA-seq genes
#'
#' @param peakMatrix A SingleCellExperiment object containing counts of chromatin accessibility at each peak region or genomic bin from scATAC-seq.
#' `rowRanges` should contain genomic positions of the peaks in the form of `GRanges`.
#' @param expMatrix A SingleCellExperiment object containing gene expression counts from scRNA-seq. `rowRanges` should contain genomic positions of
#' the genes in the form of `GRanges`. `rowData` should contain a column of gene symbols with column name matching the `gene_symbol` argument.
#' @param reducedDim A matrix of dimension reduced values
#' @param ArchR_path String specifying the path to an ArchR project if ArchR's implementation of addPeak2GeneLinks is desired
#' @param cor_cutoff A numeric scalar to specify the correlation cutoff between ATAC-seq peaks and RNA-seq genes to assign peak to gene links.
#'  Default correlation cutoff is 0.5.
#' @param useDim String specifying the dimensional reduction representation in the ArchR project to use or the name of the reduced dimension matrix supplied by the user
#' @param useMatrix String specifying which the name of the gene expression matrix in the ArchR project to use.
#' It is often called the "GeneExpressionMatrix" for multiome and "GeneIntegrationMatrix" for unpaired data in ArchR project.
#' @param cellNum An integer to specify the number of cells to include in each K-means cluster. Default is 200 cells.
#' @param maxDist An integer to specify the base pair extension from transcription start start for overlap with peak regions
#' @param exp_assay String indicating the name of the assay in expMatrix for gene expression
#' @param peak_assay String indicating the name of the assay in peakMatrix for chromatin accessibility
#' @param gene_symbol String indicating the column name in the rowData of expMatrix that corresponds to gene symbol
#' @param clusters A vector corresponding to the cluster labels for calculation of correlations within each cluster. If left NULL, correlation is calculated across
#' all clusters. See details for the use of clusters
#' @param cor_method String indicating which correlation coefficient is to be computed. One of "pearson" (default), "kendall", or "spearman".
#' @param ... other parameters to pass to addPeak2GeneLinks from ArchR package
#'
#' @return A DataFrame of Peak to Gene correlation
#' @details Cluster information is sometimes helpful to avoid the [Simpsons's paradox](https://en.wikipedia.org/wiki/Simpson%27s_paradox) in which baseline differences
#' between cell lines or cell types can create artificial or even inverse correlations between peak accessibility and gene expression. If Cluster information is provided,
#' correlation is performed within cell aggregates of each cluster.
#' @import SummarizedExperiment SingleCellExperiment GenomicRanges
#' @export
#'
#' @examples
#' # create a mock singleCellExperiment object for gene expression matrix
#' set.seed(1000)
#' gene_sce <- scuttle::mockSCE()
#' gene_sce <- scuttle::logNormCounts(gene_sce)
#' gene_gr <- GRanges(seqnames = Rle(c("chr1", "chr2", "chr3","chr4"), nrow(gene_sce)/4),
#'                    ranges = IRanges(start = seq(from = 1, length.out=nrow(gene_sce), by = 1000),
#'                    width = 100))
#' rownames(gene_sce) <- rownames(gene_sce)
#' gene_gr$name <- rownames(gene_sce)
#' rowRanges(gene_sce) <- gene_gr
#'
#' # create a mock singleCellExperiment object for peak matrix
#' peak_gr <- GRanges(seqnames = "chr1",
#'                    ranges = IRanges(start = seq(from = 1, to = 10000, by = 1000), width = 100))
#' peak_counts <- matrix(sample(x = 0:4, size = ncol(gene_sce)*length(peak_gr), replace = TRUE),
#'                       nrow = length(peak_gr), ncol=ncol(gene_sce))
#' peak_sce <- SingleCellExperiment(list(counts = peak_counts), colData = colData(gene_sce))
#' rowRanges(peak_sce) <- peak_gr
#' rownames(peak_sce) <- paste0("peak",1:10)

#' # create a mock reducedDim matrix
#' reducedDim_mat <- matrix(runif(ncol(gene_sce)*50, min = 0, max = 1), nrow = ncol(gene_sce), 50)
#' p2g <- calculateP2G(peakMatrix = peak_sce, expMatrix = gene_sce, reducedDim = reducedDim_mat,
#'                     cellNum = 20, clusters = gene_sce$Treatment)
#' @author Xiaosai Yao, Shang-yang Chen

calculateP2G <- function(peakMatrix = NULL,
                         expMatrix = NULL,
                         reducedDim = NULL,
                         ArchR_path = NULL,
                         useDim = "IterativeLSI",
                         useMatrix = "GeneIntegrationMatrix",
                         maxDist = 250000,
                         cor_cutoff = 0.5,
                         cellNum = 200,
                         exp_assay = "logcounts",
                         peak_assay = "counts",
                         gene_symbol = "name",
                         clusters = NULL,
                         cor_method = c("pearson", "kendall", "spearman"),
                         ...) {


  if (!is.null(ArchR_path)) {
    ArchR::addArchRLogging(useLogs = FALSE)

    writeLines("Using ArchR to compute peak to gene links...")
    suppressMessages(obj <- ArchR::loadArchRProject(ArchR_path))

    obj <- ArchR::addPeak2GeneLinks(
      ArchRProj = obj,
      reducedDims = useDim,
      useMatrix = useMatrix,
      logFile = "x",
      ...
    )

    p2g <- ArchR::getPeak2GeneLinks(
      ArchRProj = obj,
      corCutOff = cor_cutoff,
      resolution = 1000,
      returnLoops = FALSE
    )

    # Get metadata from p2g object and turn into df with peak indexes
    peak_metadata <- as.data.frame(S4Vectors::metadata(p2g)[[1]]) # shows  chromosome, start, and end coordinates for each peak
    peak_metadata$idxATAC <- seq_along(rownames(peak_metadata))

    gene_metadata <- as.data.frame(S4Vectors::metadata(p2g)[[2]]) # shows gene name and RNA index of genomic ranges
    gene_metadata$idxRNA <- seq_along(rownames(gene_metadata))

    # Add gene names and peak positions to dataframe
    p2g_merged <- merge(p2g, gene_metadata, by = "idxRNA") # merge by gene ID
    p2g_merged <- merge(p2g_merged, peak_metadata, by = "idxATAC") # merge by peak ID

    # Calculate distance
    p2g_merged$distance <- abs((p2g_merged$start.y + p2g_merged$end.y)/2 - (p2g_merged$start.x + p2g_merged$end.x)/2)

    # Extract relevant columns
    p2g_merged <- p2g_merged[, c("idxATAC", "seqnames.y", "start.y","end.y", "idxRNA", "name", "Correlation", "distance")]
    colnames(p2g_merged) <- c("idxATAC", "chr", "start","end", "idxRNA", "target", "Correlation", "distance")




  } else if (!is.null(peakMatrix) &
             !is.null(expMatrix) & !is.null(reducedDim)) {

    writeLines("Using epiregulon to compute peak to gene links...")

    cor_method <- match.arg(cor_method)

    if (is.null(rowRanges(peakMatrix))) {
      stop("peakMatrix must contain rowRanges")
    }
    if (is.null(rowRanges(expMatrix))) {
      stop("expMatrix must contain rowRanges")
    }

    if (! gene_symbol %in% colnames(rowData(expMatrix))) {
      stop("colData of expMatrix does not contain ", gene_symbol)
    }


    # Package expression matrix and peak matrix into a single sce
    sce <- combineSCE(expMatrix, exp_assay, peakMatrix, peak_assay, reducedDim, useDim)

    message("performing k means clustering to form metacells")

    # K-means clustering
    kNum <- trunc(ncol(sce) / cellNum)
    kclusters <- scran::clusterCells(sce,
                                     use.dimred = useDim,
                                     BLUSPARAM = bluster::KmeansParam
                                     (centers = kNum, iter.max = 5000))
    kclusters <- as.character(kclusters)


    # aggregate sce by k-means clusters
    sce_grouped <- applySCE(sce,
                            scuttle::aggregateAcrossCells,
                            ids = kclusters,
                            statistics = "mean")

    # some sces have strand information in metadata that conflicts with genomic ranges
    mcols(expMatrix)$strand <- NULL

    # keep track of original ATAC and expression indices
    rowData(sce_grouped)$old.idxRNA <- seq_len(nrow(sce_grouped))
    rowData(altExp(sce_grouped))$old.idxATAC <- seq_len(nrow(altExp(sce_grouped)))

    # remove genes and peaks that are equal to 0
    sce_grouped <- sce_grouped[which(rowSums(assay(sce_grouped)) != 0),]
    altExp(sce_grouped) <- altExp(sce_grouped)[which(rowSums(assay(altExp(sce_grouped), "counts")) != 0),]

    # extract gene expression and peak matrix
    expGroupMatrix <- assay(sce_grouped, "counts")
    peakGroupMatrix <- assay(altExp(sce_grouped), "counts")


    # get gene information
    geneSet <- rowRanges(sce_grouped)
    geneStart <- promoters(geneSet)

    # get peak range information
    peakSet <- rowRanges(altExp(sce_grouped))

    # find overlap after resizing
    o <- S4Vectors::DataFrame(findOverlaps(resize(geneStart, maxDist, "center"),
                                           peakSet,
                                           ignore.strand = TRUE))



    #Get Distance from Fixed point A B
    o$distance <- distance(geneStart[o[, 1]] , peakSet[o[, 2]])
    colnames(o) <- c("RNA", "ATAC", "distance")


    # add old idxRNA and idxATAC
    o$old.idxRNA <- rowData(sce_grouped)[o[,1],"old.idxRNA"]
    o$old.idxATAC <- rowData(altExp(sce_grouped))[o[,2],"old.idxATAC"]

    #add metadata to o
    o$Gene <-  rowData(sce_grouped)[o[,1],"name"]
    o$chr <- as.character(seqnames(rowRanges(altExp(sce_grouped))[o[,2]]))
    o$start <- GenomicRanges::start(rowRanges(altExp(sce_grouped))[o[,2],])
    o$end <- GenomicRanges::end(rowRanges(altExp(sce_grouped))[o[,2],])

    # Calculate correlation
    expCorMatrix <- expGroupMatrix[as.integer(o$RNA), ]
    peakCorMatrix <- peakGroupMatrix[as.integer(o$ATAC), ]

    writeLines("Computing correlation")

    # if a cluster is named "all", replace it to distinguish from all cells
    clusters <- renameCluster(clusters)

    unique_clusters <- sort(unique(clusters))

    o$Correlation <- initiateMatCluster(clusters, nrow = nrow(expCorMatrix))

    o$Correlation[,"all"] <- mapply(stats::cor,
                                    as.data.frame(t(expCorMatrix)),
                                    as.data.frame(t(peakCorMatrix)),
                                    MoreArgs = list(method = cor_method))

    # compute correlation within each cluster
    if (!is.null(clusters)) {
      # composition of kcluster
      cluster_composition <- table(clusters, kclusters)
      cluster_composition <- sweep(cluster_composition, 2, STATS=colSums(cluster_composition), FUN="/")

      for (cluster in unique_clusters) {
        clusters_idx <- colnames(cluster_composition)[cluster_composition[cluster,] >= 1/length(unique_clusters)]
        o$Correlation[, cluster] <- mapply(stats::cor,
                                           as.data.frame(t(expCorMatrix[,clusters_idx])),
                                           as.data.frame(t(peakCorMatrix[,clusters_idx])))
      }

    }


    p2g_merged <- o[, c("old.idxATAC", "chr","start","end", "old.idxRNA", "Gene", "Correlation", "distance")]
    colnames(p2g_merged) <- c("idxATAC", "chr", "start","end", "idxRNA", "target", "Correlation", "distance")

    correlation_max <- apply(p2g_merged$Correlation, 1, max, na.rm = TRUE)
    p2g_merged <- p2g_merged[correlation_max > cor_cutoff,,drop=FALSE]



  } else {
    stop(
      "Input obj must be either an 'ArchR' path or all 3 matrices: gene expression, chromatin accessibility and dimensionality reduction"
    )

  }
  p2g_merged <- p2g_merged[order(p2g_merged$idxATAC, p2g_merged$idxRNA),,drop=FALSE]
  return(p2g_merged)

}


combineSCE <- function(expMatrix, exp_assay, peakMatrix, peak_assay, reducedDim, useDim) {

  # convert expMatrix and peakMatrix in case they weren't already so
  expMatrix <- as(expMatrix,"SingleCellExperiment")
  peakMatrix <- as(peakMatrix,"SingleCellExperiment")


  sce <- SingleCellExperiment(list(counts = assay(expMatrix, exp_assay)),
                              altExps = list(peakMatrix =
                                               SingleCellExperiment(list(counts = assay(peakMatrix, peak_assay)))))

  rowRanges(sce) <- rowRanges(expMatrix)
  rowRanges(altExp(sce)) <- rowRanges(peakMatrix)

  # add reduced dimension information to sce object
  reducedDim(sce, useDim) <- reducedDim

  sce

}
