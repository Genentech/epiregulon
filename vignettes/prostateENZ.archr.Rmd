---
title: "prostate cancer archr tutorial"
author:
- Shang-Yang Chen^[chens179@gene.com]
- Xiaosai Yao^[yaox19@gene.com]
date: "September 4th, 2022"
output:
  BiocStyle::html_document:
    toc: true
    number_section: true
    self_contained: true
    titlecaps: true
package: epiregulon
vignette: >
  %\VignetteIndexEntry{prostate cancer archr tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE)
```

# Introduction
This tutorial walks through an example of TF activity inference in single cell multiome data. This is a dataset generated by infecting LNCaP cells with NKX2-1 and GATA6 to examine the effects of these TFs on AR activity.

# Installation

Epiregulon is currently available on R/dev

```{r, message=FALSE, results='hide'}
library(epiregulon)
library(ArchR)
```

Alternatively, you could install from gitlab

```{r setup, message=FALSE, eval=FALSE}
devtools::install_gitlab(repo='scwg/gene-transcriptional-network/activity-inference/Epiregulon', 
                         auth_token = "<gitlab token>", 
                         host = "https://code.roche.com/" )

library(epiregulon)
```

# Data preparation


Please refer to the full ArchR [manual](https://www.archrproject.com/bookdown/index.html) for instructions 

Before running Epiregulon, the following analyses need to be completed:
1. Obtain a peak matrix on scATACseq by using addGroupCoverages > addReproduciblePeakSet > addPeakMatrix. See chapter [10](https://www.archrproject.com/bookdown/calling-peaks-with-archr.html) from ArchR manual
2. RNA-seq integration. 
a. For unpaired scATAC-seq, use addGeneIntegrationMatrix. See chapter [8](https://www.archrproject.com/bookdown/defining-cluster-identity-with-scrna-seq.html) from ArchR manual
b. For multiome data, use addGeneExpressionMatrix. See [multiome](https://greenleaflab.github.io/ArchR_2020/Ex-Analyze-Multiome.html) tutorial
3. Perform dimensionality reduction from with either single modalities or joint scRNAseq and scATACseq using [addCombinedDims](https://www.archrproject.com/reference/addCombinedDims.html)

## Load ArchR project
Copy this ArchR project into your own directory
```{r, message = FALSE}
archR_project_path <- "/gstore/project/lineage/prostate/GSE168667/OUTPUT/multiome/"
proj <- loadArchRProject(path = archR_project_path, showLogo = F)

```

We verify that "GeneExpressionMatrix" and "PeakMatrix" are present for this tutorial. 

```{r}
getAvailableMatrices(proj)
```

We will use the joint reducedDims - "LSI_Combined" and  joint embeddings - "UMAP_Combined"
```{r}
getReducedDims(proj, reducedDims = "iLSI_Combined")
getEmbedding(proj, embedding = "UMAP_Combined")

```
## Retrieve matrices from ArchR project

Retrieve gene expression and peak matrix from the ArchR project
```{r}
GeneExpressionMatrix <- getMatrixFromProject(
    ArchRProj = proj,
    useMatrix = "GeneIntegrationMatrix",
    useSeqnames = NULL,
    verbose = TRUE,
    binarize = FALSE,
    threads = 1,
    logFile = "x"
)

PeakMatrix <- getMatrixFromProject(
    ArchRProj = proj,
    useMatrix = "PeakMatrix",
    useSeqnames = NULL,
    verbose = TRUE,
    binarize = FALSE,
    threads = 1,
    logFile = "x"
)

ChromVarMatrix <- getMatrixFromProject(
    ArchRProj = proj,
    useMatrix = "MotifMatrix",
    useSeqnames = NULL,
    verbose = TRUE,
    binarize = FALSE,
    threads = 1,
    logFile = "x"
)
rownames(ChromVarMatrix) <- sapply(strsplit(rownames(ChromVarMatrix), split = "_"), "[",1)
```

Convert gene expression matrix to SingleCellExperiment object
```{r}

GeneExpressionMatrix <- as(GeneExpressionMatrix, "SingleCellExperiment")
assayNames(GeneExpressionMatrix)  <-  "logcounts"
assayNames(PeakMatrix)  <-  "counts"
```

Transfer cell and gene information and embeddings from ArchR project to singleCellExperiment

```{r}
reducedDim(GeneExpressionMatrix, "UMAP_Combined") <- getEmbedding(ArchRProj = proj, 
                                                                  embedding = "UMAP_Combined", 
                                                                  returnDF = TRUE)[colnames(GeneExpressionMatrix),]
colData(GeneExpressionMatrix) <- getCellColData(proj)[colnames(GeneExpressionMatrix),]
rownames(GeneExpressionMatrix) <- rowData(GeneExpressionMatrix)$name
```

Visualize singleCellExperiment by UMAP
```{r}
scater::plotReducedDim(GeneExpressionMatrix, 
                       dimred = "UMAP_Combined", 
                       text_by = "Treatment", 
                       colour_by = "Treatment")
```


# Quick start

## Retrieve bulk TF ChIP-seq binding sites 

First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq, which are hosted on Genomitory. Currently, human genomes HG19 and HG38 and mouse mm10 are available. 

```{r getTFMotifInfo}
grl <- getTFMotifInfo(genome = "hg38")
head(grl)
```

## Link ATAC-seq peaks to target genes

Next, we compute peak to gene correlations using the `addPeak2GeneLinks` function from the ArchR package. The user would need 
to supply a path to an ArchR project already containing peak and gene matrices, as well as Latent semantic indexing (LSI) dimensionality reduction. 

```{r calculateP2G}
# path to ArchR project
p2g <- calculateP2G(ArchR_path = archR_project_path, 
                    useDim = "iLSI_Combined", 
                    useMatrix = "GeneIntegrationMatrix")
head(p2g)
```

## Add TF motif binding to peaks

The next step is to add the TF motif binding information by overlapping the regions of the peak matrix with the bulk chip-seq database loaded in 2. The user can supply either an archR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment.

```{r addTFMotifInfo}
overlap <- addTFMotifInfo(archR_project_path = archR_project_path, grl = grl, p2g = p2g)
```

## Generate regulons

A long format dataframe, representing the inferred regulons, is then generated. The dataframe consists of three columns:

* tf (transcription factor)
* target gene
* peak to gene correlation between tf and target gene

```{r getRegulon}
regulon <- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE)
head(regulon)
```

```{r}

pruned.regulon <- pruneRegulon(expMatrix = GeneExpressionMatrix,
                               peakMatrix = PeakMatrix,
                               peak_assay = "counts",
                               regulon = regulon[regulon$tf %in% c("AR","FOXA1"),],
                               clusters = proj$Sample,
                               prune_value = "pval",
                               regulon_cutoff = 0.05,
                               BPPARAM = BiocParallel::MulticoreParam(progressbar = TRUE))
```

Epiregulon computes weights using either correlation, mutual information, log fold change or wilcoxon rank sum test. In this case, we choose wilcoxon 

```{r addWeights, results = "hide", warning=FALSE}

regulon.w <- addWeights(regulon = pruned.regulon,
                        expMatrix = GeneExpressionMatrix,
                        exp_assay = "logcounts",
                        peakMatrix = PeakMatrix,
                        peak_assay = "counts",
                        clusters = proj$Sample,
                        method = "corr",
                        tf_re.merge = TRUE,
                        BPPARAM = BiocParallel::SerialParam(progressbar = TRUE))
```
```{r }
head(regulon.w)
```

## Calculate TF activity 

Finally, the activities for a specific TF in each cell are computed by averaging the weighted expressions of target genes linked to the TF.
$$y=\frac{1}{n}\sum_{i=1}^{n} x_i * weight_i$$
where $y$ is the activity of a TF for a cell
$n$ is the total number of targets for a TF
$x_i$ is the log count expression of target i where i in {1,2,...,n}
$weight_i$ is the weight of TF and target i

```{r calculateActivity, results = "hide"}
score.combine <- calculateActivity(expMatrix = GeneExpressionMatrix,
                                   regulon = regulon.w,
                                   normalize = TRUE,
                                   mode = "weight",
                                   method = "weightedMean")
```

## Perform differential activity
```{r differential}
markers <- findDifferentialActivity(activity_matrix = score.combine, 
                                    groups = proj$Sample, 
                                    pval.type = "some", 
                                    direction = "up", 
                                    test.type = "t")
```

Take the top TFs
```{r}
markers.sig <- getSigGenes(markers, topgenes = 5 )
```
## Visualize the results

First visualize the known differential TFs by bubble plot
```{r visualization}
plotBubble(activity_matrix = score.combine, 
           tf = c("AR","FOXA1"), 
           class = proj$Sample)
```

Then visualize the most differential TFs by clusters
```{r}
plotBubble(activity_matrix = score.combine, 
           tf = markers.sig$tf, 
           class = GeneExpressionMatrix$Sample)
```

Visualize the known differential TFs by violin plot. Note there is no activity calculated for SOX2 because the expression of SOX2 is 0 in all cells.

```{r}
plotActivityViolin(activity_matrix = score.combine, 
                   tf = markers.sig$tf, 
                   class = GeneExpressionMatrix$Sample)
```

Visualize the known differential TFs by UMAP
```{r, fig.height = 8, fig.width = 12}
pdf("plot.pdf")
plotActivityDim(sce = GeneExpressionMatrix,
                activity_matrix = score.combine, 
                tf = c( "AR", "FOXA1"), 
                dimtype = "UMAP_Combined", 
                label = "Sample", 
                point_size = 1, 
                ncol = 2,
                nrow = 2)
 
dev.off()
```

## Geneset enrichment
Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from [clusterProfiler](http://yulab-smu.top/biomedical-knowledge-mining-book/universal-api.html).

```{r enrichment, fig.height = 10, fig.width = 12}
#retrieve genesets
H <- EnrichmentBrowser::getGenesets(org = "hsa", db = "msigdb", cat = "H", gene.id.type = "SYMBOL" )
C6 <- EnrichmentBrowser::getGenesets(org = "hsa", db = "msigdb", cat = "C6", gene.id.type = "SYMBOL" )

#combine genesets and convert genesets to be compatible with enricher
gs <- c(H,C6)
gs.list <- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])}))

enrichresults <- regulonEnrich(TF = c("AR","FOXA1"), 
                               regulon = regulon.w, 
                               corr = "weight",
                               corr_cutoff = 0.5, 
                               genesets = gs.list)

#plot results
enrichPlot(results = enrichresults)
```
## Network analysis

We can visualize the genesets as a network
```{r}
plotGseaNetwork(tf = names(enrichresults), 
                enrichresults = enrichresults, 
                p.adj_cutoff = 0.1, 
                ntop_pathways = 10)

```

differential networks

```{r network pruning}


```
# Session Info

```{r}
sessionInfo()
```


