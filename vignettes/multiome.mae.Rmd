---
title: "Multiome tutorial - archR independent workflow"
author: Xiaosai Yao^[yaox19@gene.com]
date: "September 4th, 2022"
output: html_document
package: epiregulon
vignette: >
  %\VignetteIndexEntry{Multiome tutorial - archR independent workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

# Introduction
This tutorial walks through the same dataset used in the "multiome tutorial - archR workflow". This is a dataset generated by infecting LNCaP cells with NKX2-1 and GATA6 to examine the effects of these TFs on AR activity.

# Installation

Epiregulon is currently available on R/dev

```{r, results='hide'}
library(epiregulon)
```

Alternatively, you could install from gitlab

```{r setup, message=FALSE, eval=FALSE}
devtools::install_gitlab(repo='scwg/gene-transcriptional-network/activity-inference/Epiregulon', 
                         auth_token = "<gitlab token>", 
                         host = "https://code.roche.com/" )

library(epiregulon)

```

# Data preparation

Single cell preprocessing needs to performed by user's favorite methods prior to using Epiregulon. The following components are required: <br>
1. Peak matrix from scATAC-seq <br>
2. Gene expression matrix from either paired or unpaired scRNA-seq. RNA-seq integration needs to be performed for unpaired dataset. <br>
3. Dimensionality reduction matrix from with either single modalities or joint scRNA-seq and scATAC-seq <br>

Multiome data can now be conveniently processed by ```initiate.archr``` and then ```gp.sa.archr``` to obtain peak matrices. Finally, the archR project can be uploaded into DatasetDB as a MultiAssayExperiment object using ```maw.archr::importArchr``` or ```maw.archr::create.mae.with.multiple.sces.from.archr``` 


```{r}
# load the MAE object
mae <- dsassembly::getDataset("DS000013080")

# peak matrix
PeakMatrix <- mae[["PeakMatrix"]]
rownames(PeakMatrix) <- rowData(PeakMatrix)$idx

# expression matrix
GeneExpressionMatrix <- mae[["GeneExpressionMatrix"]]
rownames(GeneExpressionMatrix) <- rowData(GeneExpressionMatrix)$name

# dimensional reduction matrix
reducedDimMatrix <- reducedDim(mae[['TileMatrix500']], "LSI_ATAC")


```



Visualize singleCellExperiment by UMAP
```{r}
# transfer UMAP_combined from TileMatrix to GeneExpressionMatrix
reducedDim(GeneExpressionMatrix, "UMAP_Combined") <- reducedDim(mae[['TileMatrix500']], "UMAP_Combined")
scater::plotReducedDim(GeneExpressionMatrix, dimred = "UMAP_Combined", 
                       text_by = "Clusters", colour_by = "Clusters")

```

# Quick start

1. Retrieve bulk TF ChIP-seq binding sites 

First, we retrieve the information of TF binding sites collected from Cistrome and ENCODE ChIP-seq, which are hosted on Genomitory. Currently, human genomes HG19 and HG38 and mouse mm10 are available. 

```{r getTFMotifInfo}
grl <- getTFMotifInfo(genome = "hg38")
head(grl)

```

2. Link ATAC-seq peaks to target genes

Next, we compute peak to gene correlations using a custom algorithm that has similar performance to ArchR's P2G function.

```{r calculateP2G}

p2g <- calculateP2G(peakMatrix = PeakMatrix, 
                    expMatrix = GeneExpressionMatrix, 
                    reducedDim = reducedDimMatrix)

head(p2g)

```


3. Add TF motif binding to peaks

The next step is to add the TF binding information by overlapping regions of the peak matrix with the bulk chip-seq database loaded in 2. The user can supply either an archR project path and this function will retrieve the peak matrix, or a peakMatrix in the form of a Granges object or RangedSummarizedExperiment.

```{r addTFMotifInfo}

overlap <- addTFMotifInfo(grl = grl, p2g = p2g, peakMatrix = PeakMatrix)
head(overlap)
```

4. Generate regulons

A long format dataframe, representing the inferred regulons, is then generated. The dataframe consists of three columns:

* tf (transcription factor)
* target gene
* peak to gene correlation between tf and target gene

```{r, warning=FALSE, getRegulon}

regulon <- getRegulon(p2g = p2g, overlap = overlap, aggregate = FALSE)
head(regulon)
```

5. Network pruning (highly recommended)


```{r network pruning}

pruned.regulon <- calculateJointProbability(expr = GeneExpressionMatrix,
                                       expr_assay = "counts",
                                       atac = PeakMatrix,
                                       atac_assay = "counts",
                                       regulon = regulon,
                                       #clusters = GeneExpressionMatrix$Clusters,
                                       expr_cutoff = 0.5,
                                       atac_cutoff = 0)
```

6. Add Weights

Epiregulon outputs two different correlations. The first, termed "corr", is the correlation between chromatin accessibility of regulatory elements vs expression of target genes calculated by ArchR. The second, termed "weight", can be generated by the addWeights function, which compute the correlation between gene expressions of TF vs expressions of target genes, shown below. The user is required to supply the clustering or batch labels of the scRNA-seq dataset when running addWeights. "Weight" is the preferred metric for calculating activity.

```{r addWeights, results = "hide", warning=FALSE}


regulon.w <- addWeights(regulon = pruned.regulon,
                        sce = GeneExpressionMatrix,
                        cluster_factor = "Clusters",
                        exprs_values = "counts",
                        block_factor = NULL,
                        corr = TRUE,
                        MI = FALSE,
                        BPPARAM = BiocParallel::MulticoreParam())
```
```{r }
head(regulon.w)

```

7. Calculate TF activity 

Finally, the activities for a specific TF in each cell are computed by averaging expressions of target genes linked to the TF weighted by the correlation variable of user's choice. 
$$y=\frac{1}{n}\sum_{i=1}^{n} x_i * corr_i$$
where $y$ is the activity of a TF for a cell
$n$ is the total number of targets for a TF
$x_i$ is the log count expression of target i where i in {1,2,...,n}
$corr_i$ is the weight of TF and target i

```{r calculateActivity, results = "hide"}
score.combine <- calculateActivity(sce = GeneExpressionMatrix, 
                                   regulon = regulon.w, 
                                   mode = "weight", 
                                   method = "weightedMean", 
                                   assay = "counts")
```

8. Perform differential activity
```{r differential}

markers <- findDifferentialActivity(activity_matrix = score.combine, 
                                    groups = GeneExpressionMatrix$Clusters, 
                                    pval.type = "some", 
                                    direction = "up", 
                                    test.type = "t")
```

Take the top TFs
```{r}
markers.sig <- getSigGenes(markers, topgenes = 5 )

```
9. Visualize the results

First visualize the known differential TFs by bubble plot
```{r visualization}
plotBubble(activity_matrix = score.combine, 
           tf = c("NKX2-1","GATA6","FOXA1","FOXA2", "AR"), 
           class = GeneExpressionMatrix$Clusters)
```

Then visualize the most differential TFs by clusters
```{r}
plotBubble(activity_matrix = score.combine, 
           tf = markers.sig$tf, 
           class = GeneExpressionMatrix$Clusters)

```

Visualize the known differential TFs by violin plot. Note there is no activity calculated for SOX2 because the expression of SOX2 is 0 in all cells.

```{r}
plotActivityViolin(activity_matrix = score.combine, 
                   tf = c("NKX2-1","GATA6","FOXA1","FOXA2", "AR", "SOX2"), 
                   class = GeneExpressionMatrix$Clusters)
```

Visualize the known differential TFs by UMAP
```{r, fig.height = 8, fig.width = 12}

plotActivityDim(sce = GeneExpressionMatrix, activity_matrix=score.combine, 
                tf = c("NKX2-1","GATA6","FOXA1","FOXA2", "AR", "SOX2"), 
                dimtype = "UMAP_Combined", 
                label = "Clusters", 
                point_size=3, 
                ncol = 3)
```

10. Geneset enrichment

Sometimes we are interested to know what pathways are enriched in the regulon of a particular TF. We can perform geneset enrichment using the enricher function from [clusterProfiler](http://yulab-smu.top/biomedical-knowledge-mining-book/universal-api.html).

```{r enrichment, fig.height = 10, fig.width = 12}
#retrieve genesets
H <- EnrichmentBrowser::getGenesets(org = "hsa", db = "msigdb", cat = "H", gene.id.type = "SYMBOL" )
C6 <- EnrichmentBrowser::getGenesets(org = "hsa", db = "msigdb", cat = "C6", gene.id.type = "SYMBOL" )

#combine genesets and convert genesets to be compatible with enricher
gs <- c(H,C6)
gs.list <- do.call(rbind,lapply(names(gs), function(x) {data.frame(gs=x, genes=gs[[x]])}))

enrichresults <- regulonEnrich(TF = c("GATA6","AR"), 
                               regulon = regulon.w, 
                               corr = "weight",
                               corr_cutoff = 0.5, 
                               genesets = gs.list)

#plot results
enrichPlot(results = enrichresults)
```
11. Network analysis

We can visualize the genesets as a network
```{f}
plotGseaNetwork(tf = names(enrichresults), 
                enrichresults = enrichresults, 
                p.adj_cutoff = 0.1, 
                ntop_pathways = 10)
}
```

differential networks

```{r differential networks}

differential.regulon <- calculateProbability(expr = GeneExpressionMatrix,
                                       expr_assay = "counts",
                                       atac = PeakMatrix,
                                       atac_assay = "counts",
                                       regulon = regulon[regulon$tf %in% c("AR","GATA6"),],
                                       #clusters = GeneExpressionMatrix$Clusters,
                                       expr_cutoff = 0.5,
                                       atac_cutoff = 0)
```

# Session Info

```{r}
sessionInfo()
```


