% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regulonPruning.R
\name{calculateJointProbability}
\alias{calculateJointProbability}
\title{Calculate joint probability of linked TF, RE and targets}
\usage{
calculateJointProbability(
  expMatrix,
  exp_assay = "logcounts",
  exp_cutoff = 1,
  peakMatrix,
  peak_assay = "PeakMatrix",
  peak_cutoff = 0,
  chromvarMatrix = NULL,
  chromvar_assay = NULL,
  chromvar_cutoff = 0,
  regulon,
  regulon_cutoff = 0,
  clusters = NULL,
  aggregate = TRUE,
  BPPARAM = BiocParallel::MulticoreParam()
)
}
\arguments{
\item{expMatrix}{A SingleCellExperiment object or matrix containing gene expression with
with genes in the rows and cells in the columns}

\item{exp_assay}{String indicating the name of the assay in expMatrix for gene expression}

\item{exp_cutoff}{A scalar indicating the minimum gene expression for a gene to be considered
active. Default value is 1}

\item{peakMatrix}{A SingleCellExperiment object or matrix containing peak accessibility with
peaks in the rows and cells in the columns}

\item{peak_assay}{String indicating the name of the assay in peakMatrix for chromatin accessibility}

\item{peak_cutoff}{A scalar indicating the minimum peak accessibility for a peak to be
considered open. Default value is 0}

\item{chromvarMatrix}{A SingleCellExperiment object or matrix containing averaged accessibility at the TF
binding sites with tfs in the rows and cells in the columns. This can be used as an alternative to TF expression}

\item{chromvar_assay}{String indicating the name of the assay in chromvarMatrix for chromatin accessibility}

\item{chromvar_cutoff}{A scalar indicating the minimum chromvar values for a tf to be
considered active. Default value is 0}

\item{regulon}{A dataframe informing the gene regulatory relationship with the \code{tf} column
representing transcription factors, \code{idxATAC}
corresponding to the index in the peakMatrix and \code{target} column
representing target genes}

\item{regulon_cutoff}{A scalar indicating the minimum value for the joint probability of
a tf-idxATAC-target trio to be retained in the pruned regulon.}

\item{clusters}{A vector corresponding to the cluster labels of the cells if
cluster-specific joint probabilities are also required. If left \code{NULL}, joint probabilities
are calculated for all cells}

\item{aggregate}{A logical indicating whether to collapse the regulatory elements of the
same genes. If \code{TRUE}, the output will only contain tf and target. If \code{FALSE}, the output
will contain tf, idxATAC and target.}

\item{BPPARAM}{A BiocParallelParam object specifying whether calculation should be parallelized.
Default is set to BiocParallel::MulticoreParam()}
}
\value{
A dataframe of a pruned regulon containing joint probabilities for tf-idxATAC-target trios
either for all cells or for individual clusters
}
\description{
Calculate joint probability of linked TF, RE and targets
}
\details{
This function calculates the joint probability for each of the TF-peak-target trios to be
active - that is, out of all the cells, how many cells have the TF and target expression exceed
\code{exp_cutoff} and chromatin accessibility exceed \code{peak_cutoff} simultaneously.
The joint probability can be used to prune the networks since a true regulatory relationship
likely requires cells to express the transcription factor, have an accessible peak region and
expressing the target gene simultaneously. While there could be time delays between tf binding,
chromatin accessibility and target gene expression, requiring baseline expression of all three
components greatly enhances the likelihood that this regulatory relationship holds true.

This function can also compute cluster-specific joint probabilities. The output can be filtered to
generate cluster-specific networks which can be fed into differential network analysis (to be continued).

The aggregate function outputs either a bipartite network of the form TF-target (\code{aggregate = TRUE})
or a tripartite network of the form TF-RE-target (\code{aggregate = FALSE}).
}
\examples{
# create a mock singleCellExperiment object for gene expMatrixession matrix
set.seed(1000)
gene_sce <- scuttle::mockSCE()
gene_sce <- scuttle::logNormCounts(gene_sce)
rownames(gene_sce) <- paste0("Gene_",1:2000)

#' create a mock singleCellExperiment object for peak matrix
peak_gr <- GRanges(seqnames = "chr1",
                  ranges = IRanges(start = seq(from = 1, to = 10000, by = 100), width = 100))
peak_counts <- matrix(sample(x = 0:4, size = ncol(gene_sce)*length(peak_gr), replace = TRUE),
                     nrow = length(peak_gr), ncol=ncol(gene_sce))
peak_sce <- SingleCellExperiment(list(counts = peak_counts), colData = colData(gene_sce))
rownames(peak_sce) <- paste0("Peak_",1:100)

# create a mock regulon
regulon <- data.frame(tf = c(rep("Gene_1",10), rep("Gene_2",10)),
                     idxATAC = sample(1:100, 20),
                     target = c(paste0("Gene_", sample(3:2000,10)),
                                paste0("Gene_",sample(3:2000,10))))

# calculate joint probability for all cells
pruned.regulon <- calculateJointProbability(expMatrix = gene_sce,
exp_assay = "logcounts", peakMatrix = peak_sce,peak_assay = "counts",
regulon = regulon, regulon_cutoff = 0.5)

#calculate joint probability for each cluster
pruned.regulon <- calculateJointProbability(expMatrix = gene_sce,
exp_assay = "logcounts",peakMatrix = peak_sce,peak_assay = "counts",
regulon = regulon,clusters = gene_sce$Treatment,
regulon_cutoff = 0.5,aggregate = FALSE)

}
\author{
Xiaosai Yao
}
